# Огляд Nginx

## Мета: Опанувати принципи роботи та отримати навики налаштування вебсерверів.

**Caddy** — веб-сервер, розроблений для сучасних веб-додатків. Caddy простий у налаштуванні та має автоматичне Let's
Encrypt, тому ваші веб-сайти завжди захищені за замовчуванням. Це веб-сервер автора.

**Nginx** — це веб-сервер, розроблений як швидкий, ефективний і сумісний практично з усім, що ви можете собі уявити.
Особисто я досить часто ним користуюся, і, як тільки ви його зрозумієте, його насправді досить легко встановити та
налаштувати. З цією метою я написав цей посібник для початківців.

Ось короткий виклад того, яку функціональність має Nginx:

- Базовий веб-сервер
- Зворотний проксі для спрямування трафіку на кілька сайтів
- Вбудований балансир навантаження для керування трафіком на кількох веб-сайтах
- Вбудоване кешування файлів для збільшення швидкості
- WebSockets
- Підтримка FastCGI
- IPv6

Встановлюємо останню версію Nginx в вашій операційній системі або запускаємо його в Docker:

```yaml
services:
  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - "8000:80"
```

Щоб перевірити, чи встановлено останню версію Nginx виконайте:

```cmd
docker-compose up -d # Запускаємо контейнер
nginx -v
# Для перевірки виуонуємо команду:
curl http://localhost:8000
```

Результат має бути подібним на:
```
StatusCode        : 200
StatusDescription : OK
Content           : <!DOCTYPE html>
                    <html>
                    <head>
                    <title>Welcome to nginx!</title>
                    <style>
                    html { color-scheme: light dark; }
                    body { width: 35em; margin: 0 auto;
                    font-family: Tahoma, Verdana, Arial, sans-serif; }
                    </style...

```

## Запуск, зупинка, перезавантаження конфігурації

Щоб запустити nginx, потрібно запустити виконуваний файл.
Коли nginx запущений, ним можна керувати використовуючи наступний синтаксис:

```sh
nginx -s сигнал
```

Де сигнал може бути одним із наступних:

- **stop** — швидке завершення
- **quit** — плавне завершення
- **reload** — перезавантаження конфігураційного файлу
- **reopen** — повторне відкриття лог-файлів

Команда має бути виконана від імені того ж користувача, під яким було запущено nginx.
Зміни, внесені в конфігураційний файл, не будуть застосовані, доки команда для перезавантаження конфігурації не буде
вручну надіслана nginx або поки він не буде перезапущений. Для перезавантаження конфігурації виконайте:

```sh
nginx -s reload
```

У **nginx** є один **головний** і **кілька робочих процесів**. Основне завдання **головного процесу** — читання та перевірка конфігурації й керування робочими процесами.
**Робочі процеси** виконують безпосередню обробку запитів. 

Nginx використовує модель, засновану на подіях, і механізми, що залежать від операційної системи, для ефективного
розподілу запитів між робочими процесами. Кількість робочих процесів задається у конфігураційному файлі та може бути фіксованою для певної конфігурації або
автоматично встановлюватися рівною кількості доступних ядер процесора.

Робота nginx і його модулів визначається у конфігураційному файлі.  
За замовчуванням конфігураційний файл називається `nginx.conf` і розташовується в одному з каталогів:

- `/usr/local/nginx/conf`
- `/etc/nginx`
- `/usr/local/etc/nginx`

Для отримання інформації про розташування конфігураційного файлу використовуйте команду:

```sh
nginx -t
```

## Структура конфігураційного файлу

Nginx складається з модулів, які налаштовуються директивами, вказаними в конфігураційному файлі. Директиви поділяються
на прості та блочні.

- **Проста директива** складається з імені та параметрів, розділених пробілами, і завершується крапкою з комою (`;`).
- **Блочна директива** має таку ж структуру, як і проста, але замість крапки з комою після імені та параметрів йде набір
  додаткових інструкцій, які містяться всередині фігурних дужок (`{}`).

Якщо у блочній директиві можна задавати інші директиви, вона називаються **контекстом** (
наприклад: `events`, `http`, `server` і `location`).

Основні контексти:

- Директиви, розташовані у конфігураційному файлі поза будь-яким контекстом, вважаються такими, що належать до *
  *контексту `main`**.
- Контексти `events` і `http` знаходяться в **контексті `main`**.
- Контекст `server` розташовується всередині **контексту `http`**.
- Контекст `location` знаходиться всередині **контексту `server`**.

Коментарі у конфігураційному файлі починаються з символу `#`

## Директива location

Директива маэ наступний синтаксис:

```nginx
location [ = | ~ | ~* | ^~ ] uri { ... }
location @name { ... }
```
та використовуэться у контекстах `server` та `location`.
Основне призначення директиви location — вказати, як nginx повинен обробляти запити до сервера в залежності від URI.

**location** можна встановити префіксним рядком або регулярним виразом. 
Регулярні вирази визначаються або з модифікатором `~*` (для пошуку збігів без врахування регістру символів), або з модифікатором `~` (з урахуванням регістру). 
Щоб знайти location, що відповідає запиту, спершу перевіряються location, що задані префіксними рядками (префіксні location'и). 
Серед них шукається location з префіксом максимальної довжини і зберігається. 
Потім перевіряються регулярні вирази, в порядку їх послідовності в конфігураційному файлі. 
Перевірка регулярних виразів припиняється після першого збігу, і використовується відповідна конфігурація. 
Якщо співпадіння з регулярним виразом не знайдено, то використовується конфігурація збереженого раніше префіксного location'у.

Блоки location можуть бути вкладеними, з деякими винятками, про які говориться нижче.
Для операційних систем, нечутливих до регістру символів, таких як macOS та Cygwin, порівняння з префіксними рядками проводиться без урахування регістру (0.7.7).
Регулярні вирази можуть містити виділення (0.7.40), які потім можна використовувати в інших директивах.

Якщо у співпадаючого префіксного location'а максимальної довжини вказано модифікатор "^~", то регулярні вирази не перевіряються.

Крім того, за допомогою модифікатора "=" можна встановити точне співпадіння URI і location. 
При точному співпадінні пошук негайно припиняється. Наприклад, якщо запит "/" трапляється часто, то вказавши "location = /", 
можна прискорити обробку цих запитів, оскільки пошук припиниться після першого порівняння. Очевидно, що такий location не може містити вкладені location'и.

Ілюструємо вищесказане на прикладі:
```nginx
location = / {
  [ Конфігурація А ]
}
location / {
  [ Конфігурація Б ]
}
location /documents/ {
  [ Конфігурація В ]
}
location ^~ /images/ {
  [ Конфігурація Г ]
}
location ~* \.(gif|jpg|jpeg)$ {
  [ Конфігурація Д ]
}
```

Для запиту "/" буде обрана конфігурація А, для запиту "/index.html" — конфігурація Б, для запиту "/documents/document.html" — конфігурація В, для запиту "/images/1.gif" — конфігурація Г, а для запиту "/documents/1.jpg" — конфігурація Д.

Префікс "@" визначає іменований location. Такий location не використовується при звичайній обробці запитів, а призначений лише для перенаправлення в нього запитів. 
Такі location'и не можуть бути вкладеними і не можуть містити вкладені location'и.

Якщо location задано префіксним рядком із слешем в кінці, і запити обробляються за допомогою proxy_pass, fastcgi_pass, uwsgi_pass, 
scgi_pass, memcached_pass або grpc_pass, відбувається спеціальна обробка. 
У відповідь на запит з URI, рівному цій рядку, але без закінчувального слешу, буде повернено постійне перенаправлення з кодом 301 на URI з доданим в кінці слешом.

Якщо така поведінка небажана, можна встановити точне співпадіння URI та location, наприклад:
```nginx
location /user/ {
  proxy_pass http://user.example.com;
}
location = /user {
  proxy_pass http://login.example.com;
}
```
Не повний [перелік директив](https://nginx.org/ru/docs/http/ngx_http_core_module.html#alias) доступних в контексті
**location**:

- **root** - Визначає кореневу директорію для обробки запиту.
- **alias** - Вказує на шлях до файлу або директорії, який буде замінювати шлях до файлу, отриманого із запиту.
- **index** - Визначає список файлів, які потрібно використовувати як індексні файли в каталозі.
- **try_files** - Перевіряє наявність вказаних файлів у зазначеному порядку та надає відповідь, якщо файл знайдений.
- **rewrite** - Використовується для перезапису URL.
- **return** - Використовується для повернення коду статусу або редіректу.
- **proxy_pass** - Проксі для передавання запиту до іншого сервера або служби.
- **auth_basic** - Включає базову автентифікацію для захисту певного контенту.
- **access_log** - Визначає журнал доступу для конкретного `location`.

## Роздача статичного контенту

Одне з важливих завдань конфігурації `nginx` — роздача файлів, таких як зображення або статичні HTML-сторінки. 

Розглянемо приклад, у якому файли будуть роздаватися з різних локальних каталогів залежно від запиту:

- `/data/www` — містить HTML-файли
- `/data/images` — містить файли із зображеннями

Для цього потрібно відредагувати конфігураційний файл та налаштувати блок `server` всередині `http` з двома
блоками `location`.

### 1. Створення каталогів

Спочатку створіть каталог `/data/www` та покладіть у нього файл `index.html` із довільним вмістом.  
Також створіть каталог `/data/images` та додайте до нього кілька файлів із зображеннями.

### 2. Налаштування конфігураційного файлу

Загалом конфігураційний файл може містити декілька блоків `server`, які відрізняються за портами, на яких вони слухають,
та за іменем сервера.
Визначивши, який `server` буде обробляти запит, `nginx` порівнює URI, зазначений у заголовку запиту, з параметрами
директив `location`, визначених всередині блоку `server`.

Наприклад:

```nginx
user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    server {
        listen 80;
        location / {
            root /srv/static/www;
            index index.html index.htm;
        }
        location /img/ {
            alias /srv/static/images/;
        }
    }
}
```

## Налаштування простого проксі-сервера

![proxy-nginx.png](assets%2Fproxy-nginx.png)

Одним з частих застосувань nginx є використання його в якості проксі-сервера, тобто сервера, який приймає запити й
перенаправляє їх на інші сервери, отримує відповіді від них і відправляє їх клієнту.
Налаштуємо базовий проксі-сервер, який обслуговуватиме запити що приходять на визначений шлях `/proxy`.
Створимо додатковий блок серверу, який буде слухати порт 8080 і відображати статичний контент з іншого каталогу.

```nginx
server {
   listen 8080;
   location / {
      root /srv/static/www-proxy;
      index index.html;
   }
}
```
Фінальний конфігураційний файл може виглядати так:

```nginx
user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    server {
        listen 80;
        location / {
            auth_basic           "closed site";
            auth_basic_user_file  /etc/nginx/.htpasswd;
            root /srv/static/www;
            index index.html index.htm;
        }
        location /img/ {
            alias /srv/static/images/;
        }
        location /proxy {
            proxy_pass http://localhost:8080/;
        }
    }
    server {
        listen 8080;
        location / {
            root /srv/static/www-proxy;
            index index.html;
        }
    }
}
```

## Вбудовані змінні

Модуль **ngx_http_core_module** підтримує вбудовані змінні, імена яких співпадають з іменами змінних веб-сервера Apache. 
Перш за все, це змінні, які представляють собою поля заголовка запиту клієнта, такі як $http_user_agent, $http_cookie та інші.

| Variable | Description |
| --- | --- |
| `$host` | Ім'я хоста із запиту (заголовок Host) |
| `$server_name` | Ім'я сервера, що обробляє запит |
| `$remote_addr` | IP-адреса клієнта |
| `$remote_port` | Порт клієнта |
| `$request_method` | Метод HTTP-запиту (GET, POST, тощо) |
| `$request_uri` | Повний URI запиту (разом з параметрами) |
| `$query_string` або `$arg_*` | Рядок запиту (GET-параметри) |
| `$document_root` | Коренева директорія сайту |
| `$request_filename` | Абсолютний шлях до файлу, що обробляється |
| `$http_user_agent` | User-Agent клієнта |
| `$http_referer` | Заголовок Referer (звідки прийшов запит) |
| `$scheme` | Використаний протокол (http або https) |
| `$status` | Код відповіді сервера |
| `$time_iso8601` | Поточний час у форматі ISO 8601 |

### Користувацькі змінні

Можна створювати власні змінні за допомогою директиви set:

```nginx
set $custom_var "Hello, Nginx!";
```
Також змінні можна формувати за допомогою map:
```nginx
map $http_user_agent $device_type {
  ~*mobile "mobile";
  default "desktop";
}
```
У цьому випадку $device_type буде "mobile" для мобільних пристроїв та "desktop" для інших.

## Додаткові матеріали

- https://statuslist.app/nginx/variables/
- https://nginx.org/en/docs/
